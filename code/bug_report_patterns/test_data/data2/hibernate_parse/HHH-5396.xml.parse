<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<bug>
    <id>HHH-5396</id>
    <title>JPQL KEY(), ENTRY() and VALUE() does not recognize alias refs</title>
    <description>
        <paragraph id="1">
            <sentence id="1.1">The KEY() and VALUE() operators for persistent maps do not seem to be implemented in Hibernate.</sentence>
        </paragraph>
        <paragraph id="2">
            <sentence id="2.1">E.g. consider the query</sentence>
        </paragraph>
        <paragraph id="3">
            <sentence id="3.1">{code}
select m.text from MultilingualString s join s.map m where key(m) = 'de'
{code}</sentence>
        </paragraph>
        <paragraph id="4">
            <sentence id="4.1">given the following classes and mappings.</sentence>
        </paragraph>
        <paragraph id="5">
            <sentence id="5.1">{code:java}
@Embeddable
public class LocalizedString {</sentence>
        </paragraph>
        <paragraph id="6">
            <sentence id="6.1">private String language;</sentence>
        </paragraph>
        <paragraph id="7">
            <sentence id="7.1">@Column(name = "_text")
    private String text;
}</sentence>
        </paragraph>
        <paragraph id="8">
            <sentence id="8.1">@Entity
@Table(schema = "jpa", name = "multilingual_string")
public class MultilingualString {</sentence>
        </paragraph>
        <paragraph id="9">
            <sentence id="9.1">@Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    @Column(name = "string_id")
    private long id;</sentence>
        </paragraph>
        <paragraph id="10">
            <sentence id="10.1">@ElementCollection(fetch=FetchType.EAGER)
    @MapKeyColumn(name = "language_key", insertable = false, updatable = false)
    @CollectionTable(schema = "jpa", name = "multilingual_string_map", joinColumns = @JoinColumn(name = "string_id"))
    private Map&lt;String, LocalizedString&gt; map = new HashMap&lt;String, LocalizedString&gt;();
}
{code}</sentence>
        </paragraph>
        <paragraph id="11">
            <sentence id="11.1">(Note that these mappings are similar to but slightly different from the ones I used in HHH-5393.</sentence>
            <sentence id="11.2">This time the map key column has a different name, creating a redundant column I would have liked to avoid.</sentence>
            <sentence id="11.3">That way, Hibernate is at least happy about the mapping.)</sentence>
        </paragraph>
        <paragraph id="12">
            <sentence id="12.1">Running the query, I get the following exception:</sentence>
        </paragraph>
        <paragraph id="13">
            <sentence id="13.1">java.lang.IllegalArgumentException: org.hibernate.hql.ast.QuerySyntaxException: unexpected AST node:  [select m.text from de.myjourney.model.media.MultilingualString s join s.map m where key(m) = 'de']</sentence>
            <sentence id="13.2">	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1222)</sentence>
            <sentence id="13.3">	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1168)</sentence>
            <sentence id="13.4">	at org.hibernate.ejb.AbstractEntityManagerImpl.createQuery(AbstractEntityManagerImpl.java:292)</sentence>
            <sentence id="13.5">	at de.myjourney.model.test.MultilingualStringTest.createGerman(MultilingualStringTest.java:35)</sentence>
            <sentence id="13.6">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</sentence>
            <sentence id="13.7">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</sentence>
            <sentence id="13.8">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</sentence>
            <sentence id="13.9">	at java.lang.reflect.Method.invoke(Method.java:597)</sentence>
            <sentence id="13.10">	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)</sentence>
            <sentence id="13.11">	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)</sentence>
            <sentence id="13.12">	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)</sentence>
            <sentence id="13.13">	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)</sentence>
            <sentence id="13.14">	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)</sentence>
            <sentence id="13.15">	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)</sentence>
            <sentence id="13.16">	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)</sentence>
            <sentence id="13.17">	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)</sentence>
            <sentence id="13.18">	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)</sentence>
            <sentence id="13.19">	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)</sentence>
            <sentence id="13.20">	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)</sentence>
            <sentence id="13.21">	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)</sentence>
            <sentence id="13.22">	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:46)</sentence>
            <sentence id="13.23">	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)</sentence>
            <sentence id="13.24">	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)</sentence>
            <sentence id="13.25">	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)</sentence>
            <sentence id="13.26">	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)</sentence>
            <sentence id="13.27">	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)</sentence>
            <sentence id="13.28">Caused by: org.hibernate.hql.ast.QuerySyntaxException: unexpected AST node:  [select m.text from de.myjourney.model.media.MultilingualString s join s.map m where key(m) = 'de']</sentence>
            <sentence id="13.29">	at org.hibernate.hql.ast.QuerySyntaxException.convert(QuerySyntaxException.java:54)</sentence>
            <sentence id="13.30">	at org.hibernate.hql.ast.QuerySyntaxException.convert(QuerySyntaxException.java:47)</sentence>
            <sentence id="13.31">	at org.hibernate.hql.ast.ErrorCounter.throwQueryException(ErrorCounter.java:82)</sentence>
            <sentence id="13.32">	at org.hibernate.hql.ast.QueryTranslatorImpl.analyze(QueryTranslatorImpl.java:261)</sentence>
            <sentence id="13.33">	at org.hibernate.hql.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:185)</sentence>
            <sentence id="13.34">	at org.hibernate.hql.ast.QueryTranslatorImpl.compile(QueryTranslatorImpl.java:136)</sentence>
            <sentence id="13.35">	at org.hibernate.engine.query.HQLQueryPlan.&lt;init&gt;(HQLQueryPlan.java:101)</sentence>
            <sentence id="13.36">	at org.hibernate.engine.query.HQLQueryPlan.&lt;init&gt;(HQLQueryPlan.java:80)</sentence>
            <sentence id="13.37">	at org.hibernate.engine.query.QueryPlanCache.getHQLQueryPlan(QueryPlanCache.java:98)</sentence>
            <sentence id="13.38">	at org.hibernate.impl.AbstractSessionImpl.getHQLQueryPlan(AbstractSessionImpl.java:156)</sentence>
            <sentence id="13.39">	at org.hibernate.impl.AbstractSessionImpl.createQuery(AbstractSessionImpl.java:135)</sentence>
            <sentence id="13.40">	at org.hibernate.impl.SessionImpl.createQuery(SessionImpl.java:1760)</sentence>
            <sentence id="13.41">	at org.hibernate.ejb.AbstractEntityManagerImpl.createQuery(AbstractEntityManagerImpl.java:277)</sentence>
            <sentence id="13.42">	... 23 more</sentence>
        </paragraph>
        <paragraph id="14">
            <sentence id="14.1">Using upper-case 'KEY(m)', the exception is different:</sentence>
        </paragraph>
        <paragraph id="15">
            <sentence id="15.1">javax.persistence.PersistenceException: org.hibernate.exception.SQLGrammarException: could not execute query</sentence>
            <sentence id="15.2">	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1235)</sentence>
            <sentence id="15.3">	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1168)</sentence>
            <sentence id="15.4">	at org.hibernate.ejb.QueryImpl.getResultList(QueryImpl.java:250)</sentence>
            <sentence id="15.5">	at de.myjourney.model.test.MultilingualStringTest.createGerman(MultilingualStringTest.java:36)</sentence>
            <sentence id="15.6">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</sentence>
            <sentence id="15.7">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</sentence>
            <sentence id="15.8">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</sentence>
            <sentence id="15.9">	at java.lang.reflect.Method.invoke(Method.java:597)</sentence>
            <sentence id="15.10">	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)</sentence>
            <sentence id="15.11">	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)</sentence>
            <sentence id="15.12">	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)</sentence>
            <sentence id="15.13">	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)</sentence>
            <sentence id="15.14">	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)</sentence>
            <sentence id="15.15">	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)</sentence>
            <sentence id="15.16">	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)</sentence>
            <sentence id="15.17">	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)</sentence>
            <sentence id="15.18">	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)</sentence>
            <sentence id="15.19">	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)</sentence>
            <sentence id="15.20">	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)</sentence>
            <sentence id="15.21">	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)</sentence>
            <sentence id="15.22">	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:46)</sentence>
            <sentence id="15.23">	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)</sentence>
            <sentence id="15.24">	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)</sentence>
            <sentence id="15.25">	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)</sentence>
            <sentence id="15.26">	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)</sentence>
            <sentence id="15.27">	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)</sentence>
            <sentence id="15.28">Caused by: org.hibernate.exception.SQLGrammarException: could not execute query</sentence>
            <sentence id="15.29">	at org.hibernate.exception.SQLStateConverter.convert(SQLStateConverter.java:92)</sentence>
            <sentence id="15.30">	at org.hibernate.exception.JDBCExceptionHelper.convert(JDBCExceptionHelper.java:66)</sentence>
            <sentence id="15.31">	at org.hibernate.loader.Loader.doList(Loader.java:2297)</sentence>
            <sentence id="15.32">	at org.hibernate.loader.Loader.listIgnoreQueryCache(Loader.java:2172)</sentence>
            <sentence id="15.33">	at org.hibernate.loader.Loader.list(Loader.java:2167)</sentence>
            <sentence id="15.34">	at org.hibernate.loader.hql.QueryLoader.list(QueryLoader.java:448)</sentence>
            <sentence id="15.35">	at org.hibernate.hql.ast.QueryTranslatorImpl.list(QueryTranslatorImpl.java:363)</sentence>
            <sentence id="15.36">	at org.hibernate.engine.query.HQLQueryPlan.performList(HQLQueryPlan.java:196)</sentence>
            <sentence id="15.37">	at org.hibernate.impl.SessionImpl.list(SessionImpl.java:1258)</sentence>
            <sentence id="15.38">	at org.hibernate.impl.QueryImpl.list(QueryImpl.java:102)</sentence>
            <sentence id="15.39">	at org.hibernate.ejb.QueryImpl.getResultList(QueryImpl.java:241)</sentence>
            <sentence id="15.40">	... 23 more</sentence>
            <sentence id="15.41">Caused by: org.postgresql.util.PSQLException: FEHLER: Funktion key(bigint) existiert nicht</sentence>
            <sentence id="15.42">  Hint: Keine Funktion stimmt mit dem angegebenen Namen und den Argumenttypen überein. Sie müssen möglicherweise ausdrückliche Typumwandlungen hinzufügen.</sentence>
            <sentence id="15.43">  Position: 161</sentence>
            <sentence id="15.44">	at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2062)</sentence>
            <sentence id="15.45">	at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1795)</sentence>
            <sentence id="15.46">	at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:257)</sentence>
            <sentence id="15.47">	at org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:479)</sentence>
            <sentence id="15.48">	at org.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:367)</sentence>
            <sentence id="15.49">	at org.postgresql.jdbc2.AbstractJdbc2Statement.executeQuery(AbstractJdbc2Statement.java:271)</sentence>
            <sentence id="15.50">	at org.hibernate.jdbc.AbstractBatcher.getResultSet(AbstractBatcher.java:208)</sentence>
            <sentence id="15.51">	at org.hibernate.loader.Loader.getResultSet(Loader.java:1849)</sentence>
            <sentence id="15.52">	at org.hibernate.loader.Loader.doQuery(Loader.java:718)</sentence>
            <sentence id="15.53">	at org.hibernate.loader.Loader.doQueryAndInitializeNonLazyCollections(Loader.java:270)</sentence>
            <sentence id="15.54">	at org.hibernate.loader.Loader.doList(Loader.java:2294)</sentence>
            <sentence id="15.55">	... 31 more</sentence>
        </paragraph>
        <paragraph id="16">
            <sentence id="16.1">(The message from PostgreSQL means "Function key(bigint) does not exist".)</sentence>
        </paragraph>
        <paragraph id="17">
            <sentence id="17.1">I had a look at the ANTLR grammar for the query parser a while ago (which may have been before 3.5.3), and as far as I could make out, key() and value() are only recognized as lower case keywords, and while the parser accepts the syntax, it fails to generate any appropriate actions.</sentence>
        </paragraph>
        <paragraph id="18">
            <sentence id="18.1">The stack traces are up-to-date though, I just ran my test cases on Hibernate 3.5.3.</sentence>
        </paragraph>
    </description>
</bug>
