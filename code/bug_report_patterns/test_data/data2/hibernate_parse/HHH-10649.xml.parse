<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<bug>
    <id>HHH-10649</id>
    <title>When 2LC enabled, flush session and then refresh entity cause dirty read in another session / transaction</title>
    <description>
        <paragraph id="1">
            <sentence id="1.1">{code:java}
@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region = "item")
public class CacheableItem {
	private Long id;
	private String name;</sentence>
        </paragraph>
        <paragraph id="2">
            <sentence id="2.1">public CacheableItem() {
	}</sentence>
        </paragraph>
        <paragraph id="3">
            <sentence id="3.1">public CacheableItem(String name) {
		this.name = name;
	}</sentence>
        </paragraph>
        <paragraph id="4">
            <sentence id="4.1">@Id
	@GeneratedValue(generator = "increment")
	@GenericGenerator(name = "increment", strategy = "increment")
	public Long getId() {
		return id;
	}</sentence>
        </paragraph>
        <paragraph id="5">
            <sentence id="5.1">public void setId(Long id) {
		this.id = id;
	}</sentence>
        </paragraph>
        <paragraph id="6">
            <sentence id="6.1">public String getName() {
		return name;
	}</sentence>
        </paragraph>
        <paragraph id="7">
            <sentence id="7.1">public void setName(String name) {
		this.name = name;
	}
}
{code}</sentence>
        </paragraph>
        <paragraph id="8">
            <sentence id="8.1">Test case:
{code:java}
@Test
public void testUpdateAndRefresh() {
	// prepare data
	Session s = openSession();
	s.beginTransaction();
	CacheableItem item = new CacheableItem( "item" );
	s.save( item );
	s.getTransaction().</sentence>
            <sentence id="8.2">commit();
	s.close();</sentence>
        </paragraph>
        <paragraph id="9">
            <sentence id="9.1">Session s1 = openSession();
	s1.beginTransaction();</sentence>
        </paragraph>
        <paragraph id="10">
            <sentence id="10.1">CacheableItem item1 = s1.get( CacheableItem.class, item.getId() ); // into persistent context
	item1.setName( "some name" );</sentence>
        </paragraph>
        <paragraph id="11">
            <sentence id="11.1">s1.flush();
	s1.clear(); // clear persistent context
	s1.refresh( item1 );</sentence>
        </paragraph>
        <paragraph id="12">
            <sentence id="12.1">item1 = s1.get( CacheableItem.class, item.getId() );
	assertEquals( "some name", item1.getName() );</sentence>
        </paragraph>
        <paragraph id="13">
            <sentence id="13.1">// open another session
	Session s2 = sessionFactory().</sentence>
            <sentence id="13.2">openSession();
	try {
		s2.beginTransaction();
		CacheableItem item2 = s2.get( CacheableItem.class, item.getId() );</sentence>
        </paragraph>
        <paragraph id="14">
            <sentence id="14.1">assertEquals( "item", item2.getName() );</sentence>
        </paragraph>
        <paragraph id="15">
            <sentence id="15.1">} catch (PessimisticLockException expected) {
		// expected if MVCC is not enabled
	} catch (Exception e) {
		throw e;
	} finally {
		s2.getTransaction().</sentence>
            <sentence id="15.2">rollback();
		s2.close();
	}</sentence>
        </paragraph>
        <paragraph id="16">
            <sentence id="16.1">s1.getTransaction().</sentence>
            <sentence id="16.2">rollback();
	s1.close();</sentence>
        </paragraph>
        <paragraph id="17">
            <sentence id="17.1">}
{code}</sentence>
        </paragraph>
        <paragraph id="18">
            <sentence id="18.1">hibernate.properties
{code:java}
hibernate.dialect org.hibernate.dialect.H2Dialect
hibernate.connection.driver_class org.h2.Driver
hibernate.connection.url jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=true
hibernate.connection.username sa
... 
{code}
note: MVCC should be *enabled* in connection url</sentence>
        </paragraph>
        <paragraph id="19">
            <sentence id="19.1">In fact, this issue does not only replicate for refresh only, but every time we evict from the cache and reload an uncommitted entry:</sentence>
        </paragraph>
        <paragraph id="20">
            <sentence id="20.1">{code:java}
s1.getSessionFactory().</sentence>
            <sentence id="20.2">getCache().</sentence>
            <sentence id="20.3">evictEntity( CacheableItem.class, item1.getId() );
s1.evict( item1 );
s1.get(CacheableItem.class, item1.getId());
{code}</sentence>
        </paragraph>
        <paragraph id="21">
            <sentence id="21.1">So, it must be addresses such that once an entry is locked, the locked is not released when the entry is evicted.</sentence>
        </paragraph>
    </description>
</bug>
