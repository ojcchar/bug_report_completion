<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<bug>
    <id>TRUNK-46</id>
    <title>Patient.indentifiers TreeSet collection updates may result in inconsistent behavior</title>
    <description>
        <paragraph id="1">
            <sentence id="1.1">As part of sync module testing, the following behavior was observed.</sentence>
            <sentence id="1.2">From specifics of how it relates to sync and sync-based scenario, see ticket TRAC-1535.</sentence>
            <sentence id="1.3">\</sentence>
        </paragraph>
        <paragraph id="2">
            <sentence id="2.1">The core of the issue is that Patient.identifiers is a TreeSet collection which is exposed to manipulation but the codebase makes no guarantees to its proper sort.</sentence>
            <sentence id="2.2">TreeSets that hold referenced objects aren't automatically resorted when the values of these objects change.</sentence>
            <sentence id="2.3">This may, in some cases, result in TreeSet (it is actually the treemap that backs up the treeset implementation that is here in question) being internally setup in a way that produced incorrect results for remove(), contains() operations since those are implemented in treeset in terms of treepmap traversal based on results of CompareTo() operation.</sentence>
            <sentence id="2.4">In terms of PatientIdentifier, this is most evident with changing values to voided since the PatientIdentifier.CompareTo() sorts voided as 'last'.</sentence>
            <sentence id="2.5">This mean, that if a collection contains id1, id2, id3 and id1 is voided; the order should now be: id2,id3,id1.</sentence>
            <sentence id="2.6">However this does not happen.</sentence>
            <sentence id="2.7">As a result, it is possible that then identifiers.contains(id3) returns false since the treepmap is now essentially corrupted.\</sentence>
        </paragraph>
        <paragraph id="3">
            <sentence id="3.1">The practical problem in OpenMRS with the above is that hibernate processes collections exactly using contains()/remove() mechanism to evaluate if child objects need to be removed/deleted from associations.</sentence>
            <sentence id="3.2">This is already coded around in the NewPatientFormController.</sentence>
        </paragraph>
        <paragraph id="4">
            <sentence id="4.1">The following pseudo unit test demonstrates this behavior.</sentence>
            <sentence id="4.2">To debug copy it to PatientTest.PatientTest.java and execute to see the problem, follow the comments.</sentence>
            <sentence id="4.3">{code}@Test
	@Verifies(value = "should verify identifiers order in the collection order", method = "removeIdentifier(PatientIdentifier)")
	public void removeIdentifier_shouldTestIdentifierCollectionChanged() throws Exception \{
		Patient p = new Patient();
		
		PatientIdentifier pa1 = new PatientIdentifier();
		PatientIdentifier pa2 = new PatientIdentifier();
		PatientIdentifier pa3 = new PatientIdentifier();
		PatientIdentifier pa4 = new PatientIdentifier();</sentence>
        </paragraph>
        <paragraph id="5">
            <sentence id="5.1">pa2.setIdentifier("2nd-date");
		pa2.setIdentifierType(new PatientIdentifierType(1));
		pa2.setDateCreated(new Date(1000));
		pa2.setVoided(false);
		p.addIdentifier(pa2);
				
		pa4.setIdentifier("last-date");
		pa4.setIdentifierType(new PatientIdentifierType(1));
		pa4.setDateCreated(new Date(pa2.getDateCreated().</sentence>
            <sentence id="5.2">getTime() + 1000));
		pa4.setVoided(false);
		p.addIdentifier(pa4);
		
		pa1.setIdentifier("first-date");
		pa1.setIdentifierType(new PatientIdentifierType(1));
		pa1.setDateCreated(new Date(pa2.getDateCreated().</sentence>
            <sentence id="5.3">getTime() - 1000));
		pa1.setVoided(false);
		p.addIdentifier(pa1);</sentence>
        </paragraph>
        <paragraph id="6">
            <sentence id="6.1">pa3.setIdentifier("3rd-date");
		pa3.setIdentifierType(new PatientIdentifierType(1));
		pa3.setDateCreated(new Date(pa2.getDateCreated().</sentence>
            <sentence id="6.2">getTime() + 500));
		pa3.setVoided(false);
		p.addIdentifier(pa3);</sentence>
        </paragraph>
        <paragraph id="7">
            <sentence id="7.1">		//now the order should be: first-date, 2nd-date, 3rd-date, last-date</sentence>
            <sentence id="7.2">		PatientIdentifier[] pis = new PatientIdentifier rev:0; </sentence>
            <sentence id="7.3">		pis = p.getIdentifiers().toArray(pis); //NOTE: this is correct -- see the order in array in debug</sentence>
            <sentence id="7.4">		assertTrue(p.getIdentifiers().contains(pa3)); //this works</sentence>
            <sentence id="7.5">		//now change voided on 3rd-date; that should move it to last position: voided IDs are the last in order </sentence>
            <sentence id="7.6">		pa3.setVoided(true);</sentence>
            <sentence id="7.7">		pis = p.getIdentifiers().toArray(pis); //THIS IS WRONG</sentence>
            <sentence id="7.8">		assertTrue(p.getIdentifiers().contains(pa3)); //this fails</sentence>
            <sentence id="7.9">		//THIS IS RIGHT</sentence>
            <sentence id="7.10">		pa3.setVoided(false); //set it back to false so we can remove it</sentence>
            <sentence id="7.11">		p.removeIdentifier(pa3);</sentence>
            <sentence id="7.12">		pis = p.getIdentifiers().toArray(pis); //pis now has 3 elements</sentence>
            <sentence id="7.13">		pa3.setVoided(true);</sentence>
            <sentence id="7.14">		p.addIdentifier(pa3);</sentence>
            <sentence id="7.15">		pis = p.getIdentifiers().toArray(pis); //pis is sorted correctly</sentence>
            <sentence id="7.16">		assertTrue(p.getIdentifiers().contains(pa3)); //this works too</sentence>
            <sentence id="7.17">	\}</sentence>
            <sentence id="7.18">{code}</sentence>
        </paragraph>
    </description>
</bug>
